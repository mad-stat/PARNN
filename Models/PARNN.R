#' @title Probabilistic Autoregressive Neural Networkfor Time Series Forecasting

#' The probabilistic autoregressive neural network (PARNN) model is a generalization of 
#' the artificial neural network and recurrent neural network model for irregular time
#' series.

#' Autoregressive integrated moving average (ARIMA) model is applied to the time series 
#' \code{y}. The linear ARIMA model generates out-of-sample forecast along with the 
#' residulas as \code{er}. PARNN models \code{p} values of the input series \code{y} and 
#' \code{q} values of the residulas series \code{er} using a feed-forward neural network 
#' architecture. The stable neural network comprises of \code{p+q} input nodes and a 
#' single hidden layer having \code{size} nodes. A total of \code{repeats} networks are 
#' fitted at random starting point to obtain results. The model generated one-step
#' ahead forecast, multi-step ahead forecast is computed recuursively. The prediction 
#' interval of the proposal can be generated by setting \code{PI}=TRUE.

#' @param y A processed univariate time series object that contains data to be analyzed, 
#' for training.
#' @param er The residual series generated by applying the ARIMA model.
#' @param p An \code{integer} indicating the number of lagged observations of the input 
#' series modeled by the PARNN architecture.  
#' @param q An \code{integer} indicating the number of lagged observations of the residual 
#' series modeled by the PARNN architecture.
#' @param size An \code{integer} denoting the number of hidden nodes in the single hidden layer.
#' Default: \code{size} = (\code{p+q}+1)/2, to ensure stable learning.
#' @param repeats An \code{integer} representing the number of neural networks  
#' to fit with different random starting weights. These are then averaged 
#' when producing forecasts.
#' Default: 500.
#' @param lambda Parameter of the Box Cox transformation to be applied to the 
#' input series.
#' @param lambdae Parameter of the Box Cox transformation to be applied to the 
#' residual series.
#' @param model Output from a previous call to \code{PARNN}. If model is
#' passed, this same model is fitted to \code{y} without re-estimating any
#' parameters.
#' @param subset Optional vector specifying a subset of observations to be used
#' in the fit. Can be an integer index vector or a logical vector the same
#' length as \code{y}. All observations are used by default.
#' @param scale.inputs If TRUE, inputs are scaled by subtracting the column
#' means and dividing by their respective standard deviations. If \code{lambda}
#' is not \code{NULL}, scaling is applied after Box-Cox transformation.
#' @param x Deprecated. Included for backwards compatibility.
#' @param e Deprecated. Included for backwards compatibility.
#' @param \dots Other arguments passed to \code{parnn}.
#'
#' @return Returns an object of class "\code{parnn}".
#'
#' The function \code{summary} is used to obtain and print a summary of the
#' results.
#'
#' The generic accessor functions \code{fitted.values} and \code{residuals}
#' extract useful features of the value returned by \code{parnn}.
#'
#' \item{model}{A list containing information about the fitted model}
#' \item{method}{The name of the forecasting method as a character string}
#' \item{x}{The original time series.}
#' \item{e}{The residuals of the fitted ARIMA model.}
#' \item{residuals}{Residuals from the fitted model. That is x minus fitted values.}
#' \item{fitted}{Fitted values (one-step forecasts)}
#' \item{...}{Other arguments}

#' @export
parnn <- function(y,er, p,q, P=1, size, repeats=500, lambda=0.5,lambdae=0.5, model=NULL, subset=NULL, scale.inputs=TRUE,e=er, x=y, ...) {
  yname <- deparse(substitute(y))
  
  # Check for NAs in x
  if (any(is.na(x))) {
    warning("Missing values in x, omitting rows")
  }
  
  # Transform data
  if (!is.null(lambda)) {
    xx <- BoxCox(x, lambda)
    lambda <- attr(xx, "lambda")
  } else {
    xx <- x
  }
  #Transform error
  if (!is.null(lambdae)) {
    ee <- BoxCox(e, lambdae)
    lambdae <- attr(ee, "lambdae")
  } else {
    ee <- e
  }
  
  # Scale series X and eeror
  scalex <- NULL
  if (scale.inputs) {
    
    tmpx <- scale(xx, center = TRUE, scale = TRUE)
    tmpe <- scale(ee, center = TRUE, scale = TRUE)
    scalex <- list(
      center = attr(tmpx, "scaled:center"),
      scale = attr(tmpx, "scaled:scale")
    )
    scalee <- list(
      center = attr(tmpe, "scaled:center"),
      scale = attr(tmpe, "scaled:scale")
    )
    
    xx <- scale(xx, center = scalex$center, scale = scalex$scale)
    xx <- xx[, 1]
    ee <- scale(ee, center = scalee$center, scale = scalee$scale)
    ee <- ee[, 1]
  }
  # Set up lagged matrix
  n <- length(xx)
  xx <- as.ts(xx)
  m <- max(round(frequency(xx)), 1L)

    #Setting up lagged matrices for Y and Errors
  lags =1:p
  maxlag <- max(lags)
  nlag <- length(lags)
  
  
  lagse= 1:q
  maxlage <- max(lagse)
  nlage <- length(lagse)
  er <- ee[-(1:(max(maxlag, maxlage)))]
  
  y <- xx[-(1:(max(maxlag, maxlage)))]
  ##lagged matrix for x(y)
  lags.X <- matrix(NA_real_, ncol = nlag, nrow = n - maxlag)
  for (i in 1:nlag)
    lags.X[, i] <- xx[(maxlag - lags[i] + 1):(n - lags[i])]
  
  ##lagged matrix for er
  lags.E <- matrix(NA_real_, ncol = nlage, nrow = n - maxlage)
  for (i in 1:nlage)
    lags.E[, i] <- ee[(maxlage - lagse[i] + 1):(n - lagse[i])]
  max_lag_all = max(maxlag, maxlage)
  
  if (p>=q){
    
    lags.E = lags.E[(p-q+1):nrow(lags.E),]
  }
  if(p< q){
    lags.X = lags.X[(q-p+1):nrow(lags.X),]
  }
  
  #Combining lags of y and erors
  lags.X <- cbind(lags.X, lags.E)
  size <- round((NCOL(lags.X) + 1) / 2)
  # Remove missing values if present
  j <- complete.cases(lags.X, y)
  ## Stop if there's no data to fit (e.g. due to NAs or NaNs)
  if (NROW(lags.X[j,, drop=FALSE]) == 0) {
    stop("No data to fit (possibly due to NA or NaN)")
  }
  
  #Passing the value(y and err combine matrix) to average on nnet function
  fit <- avnnet(lags.X[j, , drop=FALSE], y[j], size = size, repeats = repeats)
  
  # Return results
  out <- list()
  out$x <- as.ts(x)
  out$e <- as.ts(e)
  out$m <- m
  out$p <- p
  out$q <- q
  out$P <- P
  out$scalex <- scalex
  out$scalee <- scalee
  out$size <- size
  out$lambda <- lambda
  out$lambdae <- lambdae
  out$model <- fit
  out$nnetargs <- list(...)
  
  if (NROW(lags.X[j,, drop=FALSE]) == 1){
    print("coe")
    fits <- c(rep(NA_real_, maxlag), mean(sapply(fit, predict)))
  } else{
    fits <- c(rep(NA_real_, max(maxlag, maxlage)), rowMeans(sapply(fit, predict)))
  }
  if (scale.inputs) {
    fits <- fits * scalex$scale + scalex$center
  }
  fits <- ts(fits)
  if (!is.null(lambda)) {
    fits <- InvBoxCox(fits, lambda)
  }
  out$fitted <- ts(rep(NA_real_, length(out$x)))
  out$fitted[c(rep(TRUE, max(maxlag, maxlage)), j)] <- fits
  tsp(out$fitted) <- tsp(out$x)
  out$residuals <- out$x - out$fitted
  out$lags <- lags
  out$lagse <- lagse
  out$series <- yname
  out$method <- paste("NNAR(", p,",",q, sep = "")
  if (P > 0) {
    out$method <- paste(out$method, ",", P, sep = "")
  }
  out$method <- paste(out$method, ",", size, ")", sep = "")
  if (P > 0) {
    out$method <- paste(out$method, "[", m, "]", sep = "")
  }
  out$call <- match.call()
  return(structure(out, class = c("nnetar")))
}

# Aggregate several neural network models
avnnet <- function(x, y, repeats, linout=TRUE, trace=FALSE, ...) {
  mods <- list()
  for (i in 1:repeats)
    mods[[i]] <- nnet::nnet(x, y, linout = linout, trace = trace, ...)
  return(structure(mods, class = "nnetarmodels"))
}


#' @export
print.nnetarmodels <- function(x, ...) {
  cat(paste("\nAverage of", length(x), "networks, each of which is\n"))
  print(x[[1]])
}

#' Generating forecast using Probabilistic Autoregressive Neural Network
#'
#' Forecast of desired horizon is generated along with the prediction 
#' interval (calculated through simulations).
#'
#' @param object An object of class fitted "\code{parnn}" model.
#' @param h Desired forecast horizon. 
#' @param PI If TRUE, prediction intervals are produced, otherwise only point
#' forecasts are calculated. If \code{PI} is FALSE, then \code{level},
#' \code{fan}, \code{bootstrap} and \code{npaths} are all ignored.
#' @param level Confidence level for prediction intervals.
#' @param fan If \code{TRUE}, level is set to \code{seq(51,99,by=3)}. This is
#' suitable for fan plots.
#' @param bootstrap If \code{TRUE}, then prediction intervals computed using
#' simulations with resampled residuals rather than normally distributed
#' errors. Ignored if \code{innov} is not \code{NULL}.
#' @param npaths Number of sample paths used in computing simulated prediction
#' intervals.
#' @param innov Values to use as innovations for prediction intervals. Must be
#' a matrix with \code{h} rows and \code{npaths} columns (vectors are coerced
#' into a matrix). If present, \code{bootstrap} is ignored.
#'
#' An object of class "\code{forecast}" is a list containing at least the
#' following elements:
#'   \item{model}{A list containing information about the fitted model}
#'   \item{method}{The name of the forecasting method as a character string}
#'   \item{mean}{Point forecasts as a time series}
#'   \item{lower}{Lower limits for prediction intervals}
#'   \item{upper}{Upper limits for prediction intervals}
#'   \item{level}{The confidence values associated with the prediction intervals}
#'   \item{x}{The original time series 
#'   \item{e}{The ARIMA residual series}
#'   \item{residuals}{Residuals from the fitted model.}
#'   \item{fitted}{Fitted values (one-step forecasts)}
#'   \item{...}{Other arguments}

simulate.parnn <- function(object, nsim = length(object$x), seed = NULL, xreg = NULL, future = TRUE, bootstrap = FALSE, innov = NULL, lambda = object$lambda, lambdae = object$lambdae...) {
  if (is.null(innov)) {
    if (!exists(".Random.seed", envir = .GlobalEnv, inherits = FALSE)) {
      runif(1)
    }
    if (is.null(seed)) {
      RNGstate <- get(".Random.seed", envir = .GlobalEnv)
    } else {
      R.seed <- get(".Random.seed", envir = .GlobalEnv)
      set.seed(seed)
      RNGstate <- structure(seed, kind = as.list(RNGkind()))
      on.exit(assign(".Random.seed", R.seed, envir = .GlobalEnv))
    }
  } else {
    nsim <- length(innov)
  }
  if (is.null(object$x)) {
    future <- FALSE
  }
  ## only future currently implemented
  if (!future) {
    warning("simulate.nnetar() currently only supports future=TRUE")
  }
  ## set simulation innovations
  if (bootstrap) {
    res <- na.omit(c(residuals(object, type = "innovation")))
    res <- res - mean(res)
    ## scale if appropriate
    if (!is.null(object$scalex$scale)) {
      res <- res / object$scalex$scale
    }
    e <- sample(res, nsim, replace = TRUE)
  } else if (is.null(innov)) {
    res <- na.omit(c(residuals(object, type = "innovation")))
    ## scale if appropriate
    if (!is.null(object$scalex$scale)) {
      res <- res / object$scalex$scale
    }
    e <- rnorm(nsim, 0, sd(res, na.rm = TRUE))
  } else if (length(innov) == nsim) {
    e <- innov
    if (!is.null(object$scalex$scale)) {
      e <- e / object$scalex$scale
    }
  } else if (isTRUE(innov == 0L)) {
    ## to pass innov=0 so simulation equals mean forecast
    e <- rep(innov, nsim)
  } else {
    stop("Length of innov must be equal to nsim")
  }
  ##
  tspx <- tsp(object$x)
  # Check if xreg was used in fitted model
  if (is.null(object$xreg)) {
    if (!is.null(xreg)) {
      warning("External regressors were not used in fitted model, xreg will be ignored")
    }
    xreg <- NULL
  } else {
    if (is.null(xreg)) {
      stop("No external regressors provided")
    }
    xreg <- as.matrix(xreg)
    if (NCOL(xreg) != NCOL(object$xreg)) {
      stop("Number of external regressors does not match fitted model")
    }
    if (NROW(xreg) != nsim) {
      stop("Number of rows in xreg does not match nsim")
    }
  }
  xx <- object$x
  if (!is.null(lambda)) {
    xx <- BoxCox(xx, lambda)
    lambda <- attr(xx, "lambda")
  }
  ee <- object$e  
  if (!is.null(lambdae)) {
    ee <- BoxCox(ee, lambdae)
    lambdae <- attr(ee, "lambdae")
  }
  # Check and apply scaling of fitted model
  if (!is.null(object$scalex)) {
    xx <- scale(xx, center = object$scalex$center, scale = object$scalex$scale)
    if (!is.null(xreg)) {
      xreg <- scale(xreg, center = object$scalexreg$center, scale = object$scalexreg$scale)
    }
  }
  if (!is.null(object$scalee)) {
    ee <- scale(ee, center = object$scalee$center, scale = object$scalee$scale)
  }
  
  ## Get lags used in fitted model
  lags <- object$lags
  maxlag <- max(lags)
  flag <- rev(tail(xx, n = maxlag))
  
  lagse <- object$lagse
  maxlagse <- max(lagse)
  flage <- rev(tail(ee, n = maxlagse))
  
  ## Simulate by iteratively forecasting and adding innovation
  path <- numeric(nsim)
  
  for (i in 1:nsim) {
    newdata <- c(flag[lags],flage[lagse], xreg[i, ])
    if (any(is.na(newdata))) {
      stop("I can't simulate when there are missing values near the end of the series.")
    }
    path[i] <- mean(sapply(object$model, predict, newdata = newdata)) + e[i]
    flag <- c(path[i], flag[-maxlag])
    flage <- c(path[i], flage[-maxlagse]) 
  }
  ## Re-scale simulated points
  if (!is.null(object$scalex)) {
    path <- path * object$scalex$scale + object$scalex$center
  }
  ## Add ts properties
  path <- ts(path, start = tspx[2] + 1 / tspx[3], frequency = tspx[3])
  ## Back-transform simulated points
  if (!is.null(lambda)) {
    path <- InvBoxCox(path, lambda)
  }
  return(path)
}

future_msts <- function(x, y) {
  if(NCOL(y) > 1) {
    class(y) <- c("mts", "ts", "matrix")
  } else {
    class(y) <- "ts"
  }
  if("msts" %in% class(x))
    class(y) <- c("msts", class(y))
  attr <- attributes(x)
  attr$tsp[1:2] <- attr$tsp[2] + c(1,NROW(y))/attr$tsp[3]
  attributes(y)$tsp <- attr$tsp
  attributes(y)$msts <- attr$msts
  return(y)
}

forecastmod.nnetar <- function(object, h=ifelse(object$m > 1, 2 * object$m, 10), PI=FALSE, level=80, fan=FALSE, xreg=NULL, lambda=object$lambda, lambdae = object$lambdae, bootstrap=FALSE, npaths=1000, innov=NULL, ...) {
  out <- object
  tspx <- tsp(out$x)
  
  #
  if (fan) {
    level <- seq(51, 99, by = 3)
  } else {
    if (min(level) > 0 && max(level) < 1) {
      level <- 100 * level
    } else if (min(level) < 0 || max(level) > 99.99) {
      stop("Confidence limit out of range")
    }
  }
  
  xreg <- NULL
  fcast <- numeric(h)
  xx <- object$x
  ee <- object$e
  xxreg <- xreg
  if (!is.null(lambda)) {
    xx <- BoxCox(xx, lambda)
    lambda <- attr(xx, "lambda")
  }
  if (!is.null(lambdae)) {
    ee <- BoxCox(ee, lambdae)
    lambdae <- attr(ee, "lambdae")
  }
  # Check and apply scaling of fitted model
  if (!is.null(object$scalex)) {
    xx <- scale(xx, center = object$scalex$center, scale = object$scalex$scale)
  }
  if (!is.null(object$scalee)) {
    ee <- scale(ee, center = object$scalee$center, scale = object$scalee$scale)
  }
  # Get lags used in fitted model
  lags <- object$lags
  lagse <- object$lagse
  maxlag <- max(lags)
  maxlage <- max(lagse)
  flag <- rev(tail(xx, n = maxlag))
  flage <- rev(tail(ee, n = maxlage))
  # Iterative 1-step forecast
  for (i in 1:h)
  { #print(i)
    newdata <- c(flag[lags], flage[lagse])
    if (any(is.na(newdata))) {
      stop("I can't forecast when there are missing values near the end of the series.")
    }
    fcast[i] <- mean(sapply(object$model, predict, newdata = newdata))
    flag <- c(fcast[i], flag[-maxlag])
    flage<- c(0, flage[-maxlage])
  }
  
  # Re-scale point forecasts
  if (!is.null(object$scalex)) {
    fcast <- fcast * object$scalex$scale + object$scalex$center
  }
  # Add ts properties
  fcast <- ts(fcast, start = tspx[2] + 1 / tspx[3], frequency = tspx[3])
  # Back-transform point forecasts
  if (!is.null(lambda)) {
    fcast <- InvBoxCox(fcast, lambda)
  }
  # Compute prediction intervals using simulations
  if (isTRUE(PI)) {
    nint <- length(level)
    sim <- matrix(NA, nrow = npaths, ncol = h)
    if (!is.null(innov)) {
      if (length(innov) != h * npaths) {
        stop("Incorrect number of innovations, need h*npaths values")
      }
      innov <- matrix(innov, nrow = h, ncol = npaths)
      bootstrap <- FALSE
    }
    for (i in 1:npaths)
      sim[i, ] <- simulate.parnn(object, nsim = h, bootstrap = bootstrap, xreg = xreg, lambda = lambda, innov = innov[, i], ...)
    lower <- apply(sim, 2, quantile, 0.5 - level / 200, type = 8, na.rm = TRUE)
    upper <- apply(sim, 2, quantile, 0.5 + level / 200, type = 8, na.rm = TRUE)
    if (nint > 1L) {
      lower <- ts(t(lower))
      upper <- ts(t(upper))
    }
    else {
      lower <- ts(matrix(lower, ncol = 1L))
      upper <- ts(matrix(upper, ncol = 1L))
    }
    out$lower <- future_msts(out$x, lower)
    out$upper <- future_msts(out$x, upper)
  }
  else {
    level <- NULL
    lower <- NULL
    upper <- NULL
  }
  out$mean <- future_msts(out$x, fcast)
  out$level <- level
  
  return(structure(out, class = "forecast"))
} 

#' @rdname fitted.Arima
#' @export
fitted.nnetar <- function(object, h=1, ...) {
  if (h == 1) {
    return(object$fitted)
  }
  else {
    return(hfitted(object = object, h = h, FUN = "nnetar", ...))
  }
}

#' @export
print.nnetar <- function(x, digits = max(3, getOption("digits") - 3), ...) {
  cat("Series:", x$series, "\n")
  cat("Model: ", x$method, "\n")
  # cat("  one hidden layer with",x$size,"nodes\n")
  cat("Call:   ")
  print(x$call)
  print(x$model)
  cat(
    "\nsigma^2 estimated as ", format(mean(residuals(x) ^ 2, na.rm = TRUE), digits = digits),
    "\n", sep = ""
  )
  invisible(x)
}

#' @rdname is.ets
#' @export
is.nnetar <- function(x) {
  inherits(x, "nnetar")
}

#' @rdname is.ets
#' @export
is.nnetarmodels <- function(x) {
  inherits(x, "nnetarmodels")
}

# Scale a univariate time series
scale.ts <- function(x, center=TRUE, scale=TRUE) {
  tspx <- tsp(x)
  x <- as.ts(scale.default(x, center = center, scale = scale))
  tsp(x) <- tspx
  return(x)
}


#' Implementation example
#' Fit PARNN model to the given time series data with 5 lagged original
#' observations and 5 lagged residual obseervations to generate 
#' forecast of next 3 time points along with the prediction interval
fitARIMA = auto.arima(data) 
predARIMA = forecast::forecast(fitARIMA,h=3)
er = predARIMA$residuals # Extract ARIMA errors
er[is.na(er)] <- 0 # Replace missing values in error with 0

# Fitting PARNN model
fit = parnn(data, er, p = 5, q = 5, repeats = 500)
result = forecastmod.nnetar(fit, PI = TRUE, h = 3)

 
